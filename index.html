<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Wars: Ultimate Edition</title>
    <style>
        :root {
            --bg: #0f0f13;
            --panel: #1e1e24;
            --text: #ffffff;
            /* Player Colors */
            --p1: #ff4757; /* Red */
            --p2: #2ed573; /* Green */
            --p3: #1e90ff; /* Blue */
            --p4: #ffa502; /* Orange */
            --ai: #a4b0be; /* Grey for AI */
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* --- MENUS & UI --- */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--bg);
            transition: 0.3s;
            z-index: 10;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }

        h1 { font-size: 3rem; margin: 0; text-transform: uppercase; letter-spacing: 3px; text-shadow: 0 0 20px rgba(255,255,255,0.2); }
        h3 { font-weight: 300; color: #747d8c; margin-bottom: 30px; }
        .signature { font-family: 'Courier New', monospace; color: var(--p1); font-size: 1rem; margin-top: 10px; }

        .btn-group { display: flex; flex-direction: column; gap: 15px; width: 250px; }
        
        button {
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
        }

        .btn-mode { background: var(--panel); color: white; border: 1px solid #333; }
        .btn-mode:hover { background: var(--text); color: black; transform: scale(1.05); }

        /* --- GAME BOARD AREA --- */
        .game-header {
            display: flex;
            justify-content: space-between;
            width: 90%;
            max-width: 450px;
            margin-top: 20px;
            align-items: center;
        }

        .turn-indicator {
            padding: 5px 15px;
            border-radius: 20px;
            background: #333;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .turn-dot { width: 10px; height: 10px; border-radius: 50%; background: white; }

        /* Scoreboard */
        .scoreboard {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            background: var(--panel);
            padding: 10px;
            border-radius: 10px;
        }
        .score-pill {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.8rem;
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 50px;
            border-bottom: 2px solid transparent;
        }

        /* Timer Bar */
        .timer-container {
            width: 340px;
            height: 6px;
            background: #333;
            margin: 10px 0;
            border-radius: 3px;
            overflow: hidden;
        }
        .timer-fill {
            height: 100%;
            width: 100%;
            background: white;
            transition: width 1s linear;
        }

        /* Grid */
        .board {
            background: #2f3542;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(4, 80px);
            gap: 10px;
        }
        .cell {
            width: 80px; height: 80px;
            background: #1e1e24;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
        }
        .cell:hover { background: #2c2c35; }

        .tile {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            border-radius: 8px;
            font-size: 24px; font-weight: bold; color: white;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: inset 0 0 15px rgba(0,0,0,0.2);
        }

        /* Dynamic Player Colors */
        .p1-bg { background: var(--p1); }
        .p2-bg { background: var(--p2); }
        .p3-bg { background: var(--p3); }
        .p4-bg { background: var(--p4); }
        .p-ai-bg { background: var(--ai); } /* AI Color */

        .p1-txt { color: var(--p1); }
        .p2-txt { color: var(--p2); }
        .p3-txt { color: var(--p3); }
        .p4-txt { color: var(--p4); }

        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }

        /* Modal */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal.active { display: flex; }
        .winner-msg { font-size: 2.5rem; font-weight: bold; margin-bottom: 20px; text-align: center;}

    </style>
</head>
<body>

    <div class="screen" id="menuScreen">
        <h1>2048 WARS</h1>
        <h3>Tac-Tac-Toe Edition</h3>
        
        <div class="btn-group">
            <button class="btn-mode" onclick="startGame('ai')">1 Player (vs AI)</button>
            <button class="btn-mode" onclick="startGame('2p')">2 Players</button>
            <button class="btn-mode" onclick="startGame('4p')">4 Players (Chaos)</button>
        </div>

        <div class="signature">Developed by Umaiz Sufiyan</div>
    </div>

    <div class="screen hidden" id="gameScreen">
        <div class="game-header">
            <div class="turn-indicator" id="turnIndicator">
                <div class="turn-dot" id="turnDot"></div>
                <span id="turnText">Player 1's Turn</span>
            </div>
            <button onclick="toMenu()" style="padding: 5px 10px; font-size: 0.8rem;">MENU</button>
        </div>

        <div class="scoreboard" id="scoreboard">
            </div>

        <div class="timer-container">
            <div class="timer-fill" id="timerBar"></div>
        </div>

        <div class="board">
            <div class="grid" id="grid">
                </div>
        </div>
        
        <div class="signature" style="margin-top: 15px; font-size: 0.8rem; opacity: 0.6;">Umaiz Sufiyan</div>
    </div>

    <div class="modal" id="modal">
        <div class="winner-msg" id="winnerMsg">PLAYER 1 WINS!</div>
        <button class="btn-mode" onclick="resetGame()" style="background: white; color: black;">PLAY AGAIN</button>
        <button class="btn-mode" onclick="toMenu()" style="background: transparent; border: 1px solid #555; margin-top: 10px;">MAIN MENU</button>
    </div>

    <script>
        // --- GAME CONFIG & STATE ---
        const CONFIG = {
            size: 4,
            turnTime: 10 // seconds
        };

        const PLAYERS = {
            1: { name: 'Player 1', color: 'var(--p1)', class: 'p1-bg', txt: 'p1-txt', wins: 0, type: 'human' },
            2: { name: 'Player 2', color: 'var(--p2)', class: 'p2-bg', txt: 'p2-txt', wins: 0, type: 'human' },
            3: { name: 'Player 3', color: 'var(--p3)', class: 'p3-bg', txt: 'p3-txt', wins: 0, type: 'human' },
            4: { name: 'Player 4', color: 'var(--p4)', class: 'p4-bg', txt: 'p4-txt', wins: 0, type: 'human' }
        };

        let state = {
            board: [],
            mode: '2p', // ai, 2p, 4p
            activePlayers: [],
            turnIndex: 0,
            timer: null,
            timeLeft: 10,
            gameOver: false
        };

        // --- DOM ELEMENTS ---
        const els = {
            menu: document.getElementById('menuScreen'),
            game: document.getElementById('gameScreen'),
            grid: document.getElementById('grid'),
            turnText: document.getElementById('turnText'),
            turnDot: document.getElementById('turnDot'),
            timerBar: document.getElementById('timerBar'),
            scoreboard: document.getElementById('scoreboard'),
            modal: document.getElementById('modal'),
            winnerMsg: document.getElementById('winnerMsg')
        };

        // --- NAVIGATION ---
        function startGame(mode) {
            state.mode = mode;
            els.menu.classList.add('hidden');
            els.game.classList.remove('hidden');

            // Setup Players based on mode
            if (mode === 'ai') {
                state.activePlayers = [1, 2];
                PLAYERS[2].name = "AI Bot";
                PLAYERS[2].type = "ai";
                PLAYERS[2].color = "var(--ai)";
                PLAYERS[2].class = "p-ai-bg";
            } else if (mode === '2p') {
                state.activePlayers = [1, 2];
                PLAYERS[2].name = "Player 2";
                PLAYERS[2].type = "human";
                PLAYERS[2].class = "p2-bg";
            } else {
                state.activePlayers = [1, 2, 3, 4];
                PLAYERS[2].name = "Player 2";
                PLAYERS[2].class = "p2-bg";
            }

            renderScoreboard();
            resetGame();
        }

        function toMenu() {
            clearInterval(state.timer);
            els.modal.classList.remove('active');
            els.game.classList.add('hidden');
            els.menu.classList.remove('hidden');
        }

        function resetGame() {
            els.modal.classList.remove('active');
            state.gameOver = false;
            state.turnIndex = 0;
            state.board = Array(CONFIG.size).fill(null).map(() => Array(CONFIG.size).fill(null));
            
            initGrid();
            updateTurnUI();
            startTurn();
        }

        // --- CORE GAMEPLAY ---
        function initGrid() {
            els.grid.innerHTML = '';
            for(let r=0; r<CONFIG.size; r++) {
                for(let c=0; c<CONFIG.size; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.onclick = () => handleInput(r, c);
                    els.grid.appendChild(cell);
                }
            }
        }

        function getCurrentPlayerId() {
            return state.activePlayers[state.turnIndex];
        }

        function handleInput(r, c) {
            if (state.gameOver) return;
            
            const pid = getCurrentPlayerId();
            if (PLAYERS[pid].type === 'ai') return; // Ignore clicks during AI turn

            makeMove(r, c, pid);
        }

        function makeMove(r, c, pid) {
            if (state.board[r][c] !== null) return; // Spot taken

            // 1. Logic: Determine Value & Steal
            let finalValue = 2;
            let mergeOccurred = false;

            // Check neighbors for merges (The "Steal" Mechanic)
            // If neighbor has value X and we place X, they merge into the new spot
            let neighbors = [{r:r-1, c:c}, {r:r+1, c:c}, {r:r, c:c-1}, {r:r, c:c+1}];
            
            // Loop a few times to handle 2+2=4, 4+4=8 chains
            for(let i=0; i<3; i++) {
                neighbors.forEach(n => {
                    if (isValid(n.r, n.c) && state.board[n.r][n.c]) {
                        if (state.board[n.r][n.c].val === finalValue) {
                            // Merge! Remove neighbor
                            let cellDiv = document.querySelector(`.cell[data-r="${n.r}"][data-c="${n.c}"]`);
                            cellDiv.innerHTML = ''; 
                            state.board[n.r][n.c] = null;
                            
                            finalValue *= 2;
                            mergeOccurred = true;
                        }
                    }
                });
            }

            // 2. Update State
            state.board[r][c] = { val: finalValue, owner: pid };
            renderTile(r, c);

            // 3. Check Win
            if (checkWin(pid, finalValue)) return;

            // 4. Next Turn
            nextTurn();
        }

        function nextTurn() {
            state.turnIndex = (state.turnIndex + 1) % state.activePlayers.length;
            updateTurnUI();
            startTurn();
        }

        function startTurn() {
            clearInterval(state.timer);
            state.timeLeft = CONFIG.turnTime;
            updateTimerBar();

            // Timer Tick
            state.timer = setInterval(() => {
                state.timeLeft--;
                updateTimerBar();
                if(state.timeLeft <= 0) {
                    clearInterval(state.timer);
                    makeRandomMove(); // Time out = Random Move
                }
            }, 1000);

            // AI Check
            const pid = getCurrentPlayerId();
            if (PLAYERS[pid].type === 'ai') {
                setTimeout(aiLogic, 800); // Small delay for realism
            }
        }

        function makeRandomMove() {
            let empty = getEmptySpots();
            if (empty.length === 0) {
                endGame(null, "DRAW");
                return;
            }
            let spot = empty[Math.floor(Math.random() * empty.length)];
            makeMove(spot.r, spot.c, getCurrentPlayerId());
        }

        // --- AI LOGIC (Single Player) ---
        function aiLogic() {
            if(state.gameOver) return;

            let empty = getEmptySpots();
            if(empty.length === 0) return;

            let bestMove = null;

            // 1. Try to merge (Offense)
            for (let spot of empty) {
                let neighbors = getNeighbors(spot.r, spot.c);
                // If a neighbor is a '2', placing here creates a '4'. Good move.
                if (neighbors.some(n => n && n.val === 2)) {
                    bestMove = spot;
                    break;
                }
            }

            // 2. Else Random
            if (!bestMove) {
                bestMove = empty[Math.floor(Math.random() * empty.length)];
            }

            makeMove(bestMove.r, bestMove.c, getCurrentPlayerId());
        }

        // --- WIN CONDITIONS ---
        function checkWin(pid, val) {
            // 1. 2048 Win
            if (val >= 2048) {
                endGame(pid, "REACHED 2048!");
                return true;
            }

            // 2. Tic-Tac-Toe Win (4 in a row)
            // Horizontal
            for(let r=0; r<CONFIG.size; r++) {
                if(checkLine(state.board[r], pid)) { endGame(pid, "4 IN A ROW!"); return true; }
            }
            // Vertical
            for(let c=0; c<CONFIG.size; c++) {
                let col = [state.board[0][c], state.board[1][c], state.board[2][c], state.board[3][c]];
                if(checkLine(col, pid)) { endGame(pid, "4 IN A ROW!"); return true; }
            }
            // Diagonals
            let d1 = [state.board[0][0], state.board[1][1], state.board[2][2], state.board[3][3]];
            let d2 = [state.board[0][3], state.board[1][2], state.board[2][1], state.board[3][0]];
            if(checkLine(d1, pid) || checkLine(d2, pid)) { endGame(pid, "DIAGONAL WIN!"); return true; }

            // 3. Draw
            if (getEmptySpots().length === 0) {
                endGame(null, "NO MOVES LEFT - DRAW");
                return true;
            }

            return false;
        }

        function checkLine(arr, pid) {
            return arr.every(cell => cell && cell.owner === pid);
        }

        function endGame(pid, reason) {
            clearInterval(state.timer);
            state.gameOver = true;
            
            if (pid) {
                PLAYERS[pid].wins++;
                els.winnerMsg.innerHTML = `<span style="color:${PLAYERS[pid].color}">${PLAYERS[pid].name}</span><br>${reason}`;
            } else {
                els.winnerMsg.innerHTML = "DRAW GAME";
            }
            
            renderScoreboard();
            setTimeout(() => els.modal.classList.add('active'), 500);
        }

        // --- UTILS & RENDERERS ---
        function isValid(r, c) { return r >= 0 && r < CONFIG.size && c >= 0 && c < CONFIG.size; }
        
        function getEmptySpots() {
            let spots = [];
            for(let r=0; r<CONFIG.size; r++) 
                for(let c=0; c<CONFIG.size; c++) 
                    if(!state.board[r][c]) spots.push({r,c});
            return spots;
        }

        function getNeighbors(r, c) {
            let n = [];
            if(isValid(r-1, c)) n.push(state.board[r-1][c]);
            if(isValid(r+1, c)) n.push(state.board[r+1][c]);
            if(isValid(r, c-1)) n.push(state.board[r][c-1]);
            if(isValid(r, c+1)) n.push(state.board[r][c+1]);
            return n;
        }

        function renderTile(r, c) {
            let data = state.board[r][c];
            let cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
            cell.innerHTML = `
                <div class="tile ${PLAYERS[data.owner].class}">
                    ${data.val}
                </div>
            `;
        }

        function updateTurnUI() {
            const pid = getCurrentPlayerId();
            els.turnText.innerText = `${PLAYERS[pid].name}'s Turn`;
            els.turnText.style.color = PLAYERS[pid].color;
            els.turnDot.style.background = PLAYERS[pid].color;
        }

        function updateTimerBar() {
            let pct = (state.timeLeft / CONFIG.turnTime) * 100;
            els.timerBar.style.width = pct + "%";
            const pid = getCurrentPlayerId();
            els.timerBar.style.background = PLAYERS[pid].color;
        }

        function renderScoreboard() {
            els.scoreboard.innerHTML = '';
            state.activePlayers.forEach(id => {
                let p = PLAYERS[id];
                els.scoreboard.innerHTML += `
                    <div class="score-pill" style="border-bottom-color: ${p.color}">
                        <span style="font-weight:bold; color:${p.color}">${p.wins}</span>
                        <span style="font-size:0.6rem; opacity:0.7">${p.name}</span>
                    </div>
                `;
            });
        }

    </script>
</body>
</html>